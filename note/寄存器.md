# 第二章 寄存器

一个典型的 `CPU` 由运算器、控制器、寄存器等器件构成，这些器件靠内部总线相连。

前一章所说的总线，相对于 `CPU` 内部来说是外部总线。内部总线实现 `CPU` 内部各个器件之间的联系，外部总线实现 `CPU` 和主板上其他器件的联系。

在 `CPU` 中:
- 运算器进行信息处理
- 寄存器进行信息存储
- 控制器控制各种器件进行工作
- 内部总线连接各种器件，在它们之间进行数据的传送

寄存器是 `CPU` 中程序员可以用指令读写的部件。程序员通过改变各种寄存器中的内容来实现对 `CPU` 的控制。

不同的 `CPU`，寄存器的个数、结构是不相同的。`8086CPU` 有 `14` 个寄存器，每个寄存器有一个名称。这些寄存器是: `AX`、`BX`、`CX`、`DX`、`SI`、`DI`、`SP`、`BP`、`IP`、`CS`、`SS`、`DS`、`ES`、`PSW`。

## 2.1 通用寄存器

`8086CPU` 的所有寄存器都是 `16` 位的，可以存放两个字节。`AX`、`BX`、`CX`、`DX` 这 `4` 个寄存器通常用来存放一般性的数据，被称为通用寄存器。

以 `AX` 为例，寄存器的逻辑结构如图所示:

![009]()

`8086CPU` 的上一代 `CPU` 中的寄存器都是 `8` 位的，为了保证兼容，使原来基于上代 `CPU` 编写的程序稍加修改就可以运行在 `8086` 之上，`8086CPU` 的 `AX`、`BX`、`CX`、`DX` 这 `4` 个寄存器都可分为两个可独立使用的 `8` 位寄存器来用:

- `AX` 可分为 `AH` 和 `AL`
- `BX` 可分为 `BH` 和 `BL`
- `CX` 可分为 `CH` 和 `CL`
- `DX` 可分为 `DH` 和 `DL`

![010]()

以 `AX` 为例，`8086CPU` 的 `16` 位寄存器分为两个 `8` 位寄存器的情况如图所示:

![011]()

`AX` 的低 `8` 位构成了 `AL` 寄存器，高 `8` 位构成了 `AH` 寄存器。`AH` 和 `AL` 寄存器是可以独立使用的 `8` 位寄存器。

![012]()

## 2.2 字在寄存器中的存储

出于对兼容性的考虑，`8086CPU` 可以一次性处理以下两种尺寸的数据:
- 字节: 记为 `byte`，一个字节由 `8` 个 `bit` 组成，可以存在 `8` 位寄存器中。
- 字: 记为 `word`，一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节，如图所示:

![013]()

一个字可以存在一个 `16` 位寄存器中，这个字的高位字节和低位字节自然就存在这个寄存器的高 `8` 位寄存器和低 `8` 位寄存器中。

例如，一个字型数据 `20000`，存在 `AX` 寄存器中，在 `AH` 中存储了它的高 `8` 位，在 `AL` 中存储了它的低 `8` 位。`AH` 和 `AL` 中的数据，既可以看成是一个字型数据的高 `8` 位和低 `8` 位，这个字型数据的大小是 `20000`；又可以看成是两个独立的字节型数据，它们的大小分别是 `78` 和 `32`。

## 2.3 几条汇编指令

通过汇编指令控制 `CPU` 进行工作，看一下表中的几条指令:

![014]()

在写一条汇编指令或一个寄存器的名称时不区分大小写。如: `mov ax,18` 和 `MOV AX,18` 的含义相同

接下来看一下 `CPU` 执行表中所列的程序段中的每条指令后，对寄存器中的数据进行的改变:

![015]()

程序段中的最后一条指令 `add ax,bx`，在执行前 `ax` 和 `bx` 中的数据都为 `8226H`，相加后
所得的值为: `1044CH`，但是 `ax` 为 `16` 位寄存器，只能存放 `4` 位十六进制的数据，所以最
高位的 `1` 不能在 `ax` 中保存，`ax` 中的数据为: `044CH`。

![016]()

程序段中的最后一条指令 `add al,93H`，在执行前，`al` 中的数据为 `C5H`，相加后所得的值为: `158H`，但是 `al` 为 `8` 位寄存器，只能存放两位十六进制的数据，所以最高位的 `1` 丢失，ax中的数据为: `0058H`（这里的丢失，指的是进位值不能在 `8` 位寄存器中保存，但是 `CPU` 并不真的丢弃这个进位值)。

注意，此时 `al` 是作为一个独立的 `8` 位寄存器来使用的，和 `ah` 没有关系，`CPU` 在执行这条指令时认为ah和al是两个不相关的寄存器。不要错误地认为，诸如 `add al,93H` 的指令产生的进位会存储在 `ah` 中，`add al,93H` 进行的是 `8` 位运算。

如果执行 `add ax,93H`，低 `8` 位的进位会存储在 `ah` 中，`CPU` 在执行这条指令时认为只有一个 `16` 位寄存器 `ax`，进行的是 `16` 位运算。指令 `add ax,93H` 执行后，`ax` 中的值为: `0158H`。相当于将 `ax` 中的 `16` 位数据 `00c5H` 和另一个 `16` 位数据 `0093H` 相加，结果是 `16` 位的 `0158H`。

在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的。

## 2.4 物理地址

CPU 访问内存单元时，要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有唯一的地址，这个唯一的地址称为物理地址。

CPU 通过地址总线送入存储器的，必须是一个内存单元的物理地址。在 CPU 向地址总线上发出物理地址之前，必须要在内部先形成这个物理地址。不同的 CPU 可以有不同的形成物理地址的方式。

## 2.5 `16` 位结构的 `CPU`

`8086CPU` 的上一代 `CPU`（`8080`、`8085`）等是 `8` 位机，`8086` 是 `16` 位机，也可以说 `8086` 是 `16` 位结构的 `CPU`。

概括地讲，`16` 位结构描述了一个 `CPU` 具有下面几方面的结构特性:
- 运算器一次最多可以处理 `16` 位的数据
- 寄存器的最大宽度为 `16` 位
- 寄存器和运算器之间的通路为 `16` 位

`8086` 是 `16` 位结构的 `CPU`，这也就是说，在 `8086` 内部，能够一次性处理、传输、暂时存储的信息的最大长度是 `16` 位的。内存单元的地址在送上地址总线之前，必须在 `CPU` 中处理、传输、暂时存放。

## 2.6 `8086CPU` 给出物理地址的方法

`8086CPU` 有 `20` 位地址总线，可以传送 `20` 位地址，达到 `1MB` 寻址能力。`8086CPU` 又是 `16` 位结构，在内部一次性处理、传输、暂时存储的地址为 `16` 位。从 `8086CPU` 的内部结构来看，如果将地址从内部简单地发出，那么它只能送出 `16` 位的地址，表现出的寻址能力只 `64KB`。

`8086CPU` 采用一种在内部用两个 `16` 位地址合成的方法来形成一个 `20` 位的物理地址。

![017]()

如图所示，当 `8086CPU` 要读写内存时:
- `CPU` 中的相关部件提供两个 `16` 位的地址，一个称为段地址，另一个称为偏移地址
- 段地址和偏移地址通过内部总线送入一个称为地址加法器的部件
- 地址加法器将两个 `16` 位地址合成为一个 `20` 位的物理地址
- 地址加法器通过内部总线将 `20` 位物理地址送入输入输出控制电路
- 输入输出控制电路将 `20` 位物理地址送上地址总线
- `20` 位物理地址被地址总线传送到存储器

地址加法器采用 **物理地址=段地址*16+偏移地址** 的方法用段地址和偏移地址合成物理
地址。

例如，`8086CPU` 要访问地址为 `123C8H` 的内存单元，此时，地址加法器的工作过程如图所示:

![018]()

段地址 `*16` 有一个更为常用的说法是左移 `4` 位。段地址也是以二进制的形式存储的。


- 一个数据的二进制形式左移 `1` 位，相当于该数据乘以 `2`
- 一个数据的二进制形式左移 `N` 位，相当于该数据乘以 `2` 的 `N` 次方
- 地址加法器完成段地址 `*16` 的运算就是将以二进制形式存放的段地址左移 `4` 位
- 一个数据的十六进制形式左移 `1` 位，相当于乘以 `16`
- 一个数据的十进制形式左移 `1` 位，相当于乘以 `10`
- 一个 `X` 进制的数据左移 `1` 位，相当于乘以 `X`

## 2.7 **段地址*16+偏移地址=物理地址** 的本质含义

**段地址*16+偏移地址=物理地址**的本质含义是: `CPU` 在访问内存时，用一个基础地址和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。

更一般地说，`8086CPU` 的这种寻址功能是**基础地址+偏移地址=物理地址**寻址模式的一种具体实现方案。`8086CPU` 中，段地址 `*16` 可看作是基础地址。

打一个比方:

学校、体育馆、图书馆同在一条笔直的单行路上，学校位于路的起点:

![019]()

从学校到图书馆，可以用两种方式表示图书馆的地址:
- 从学校走 `2826m` 到图书馆。这 `2826m` 可以认为是图书馆的物理地址
- 从学校走 `2000m` 到体育馆，从体育馆再走 `826m` 到图书馆。第一个距离 `2000m` 是相对于起点的基础地址，第二个距离 `826m` 是相对于基础地址的偏移地址。

第一种方式是直接给出物理地址 `2826m`，而第二种方式是用基础地址和偏移地址相加来得到物理地址的。

为上面的例子加一些限制条件，比如，只能通过纸条来互相通信。显然，必须有一张可以容纳4位数据的纸条，才能写下 `2826` 这个数据。

![020]()

但仅有两张可以容纳 `3` 位数据的纸条。这样只能以这种方式表示 `2826` 这个数据:

![021]()

在第一张纸上写上 `200`（段地址），在第二张纸上写上 `826`（偏移地址）。

约定: 得到这两张纸后，做这样的运算: `200（段地址）* 10 + 826（偏移地址）= 2826（物理地址）`。

## 2.8 段的概念

内存并没有分段，段的划分来自于 CPU，由于 8086CPU 用**基础地址（段地址*16+偏移地址=物理地址**的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。

![022]()

如图所示，我们可以认为: 地址 `10000H~100FFH` 的内存单元组成一个段，该段的起始地址（基础地址）为 `10000H`，段地址为 `1000H`，大小为 `100H`（`100FFH - 10000H + 1 = FFH + 1 = 100H`）。

我们也可以认为地址 `10000H~1007FH`、`10080H~100FFH` 的内存单元组成两个段，它们的起始地址（基础地址）为: `10000H` 和 `10080H`，段地址为: `1000H` 和 `1008H`，大小都为 `80H`。

`CPU` 可以用不同的段地址和偏移地址形成同一个物理地址。

在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用段地址 `*16` 定位段的起始地址（基础地址），用偏移地址定位段中的内存单元。

有两点需要注意:
- 段地址 `*16` 必然是 `16` 的倍数，所以一个段的起始地址也一定是 `16` 的倍数
- 偏移地址为 `16` 位，`16` 位地址的寻址能力为 `64KB`，所以一个段的长度最大为 `64KB`。

## 2.9 段寄存器

`8086CPU` 在访问内存时要由相关部件提供内存单元的段地址和偏移地址，送入地址加法器合成物理地址。

段地址在 `8086CPU` 的段寄存器中存放。`8086CPU` 有 `4` 个段寄存器: `CS`、`DS`、`SS`、`ES`。当 `8086CPU` 要访问内存时由这 `4` 个段寄存器提供内存单元的段地址。

## 2.10 `CS` 和 `IP`

`CS` 和 `IP` 是 `8086CPU` 中两个最关键的寄存器，它们指示了 `CPU` 当前要读取指令的地址。`CS` 为代码段寄存器，`IP` 为指令指针寄存器。

在 `8086PC` 机中，任意时刻，设 `CS` 中的内容为 `M`，`IP` 中的内容为 `N`，`8086CPU` 将从内存 `M*16+N` 单元开始，读取一条指令并执行。

也可以这样表述: `8086` 机中，任意时刻，`CPU` 将 `CS:IP` 指向的内容当作指令执行。

下图展示了 `8086CPU` 读取、执行指令的工作原理:

![023]()

- `8086CPU` 当前状态: `CS` 中的内容为 `2000H`，`IP` 中的内容为 `0000H`
- 内存 `20000H~20009H` 单元存放着可执行的机器码
- 内存 `20000H~20009H` 单元中存放的机器码对应的汇编指令如下:
  - 地址: `20000H~20002H`，内容: `B8 23 01`，长度: `3Byte`，对应汇编指令: `mov ax,0123H`
  - 地址: `20003H~20005H`，内容: `BB 03 00`，长度: `3Byte`，对应汇编指令: `movb x，0003H`
  - 地址: `20006H~20007H`，内容: `89 D8`，长度: `2Byte`，对应汇编指令: `mov ax,bx`
  - 地址: `20008H~20009H`，内容: `01 D8`，长度: `2Byte`，对应汇编指令: `add ax,bx`

下面的一组图，展示了8086CPU 读取、执行一条指令的过程:

![024]()

- 从 `CS:IP` 指向的内存单元读取指令，读取的指令进入指令缓冲器
- `IP=IP+所读取指令的长度`，从而指向下一条指令
- 执行指令。转到步骤 1，重复这个过程

在 `8086CPU` 加电启动或复位后（即 `CPU` 刚开始工作时）`CS` 和 `IP` 被设置为 `CS=FFFFH`，`IP=0000H`。即在 `8086PC` 机刚启动时，`CPU` 从内存 `FFFF0H` 单元中读取指令执行，`FFFF0H` 单元中的指令是 `8086PC` 机开机后执行的第一条指令。

在内存中，指令和数据没有任何区别，都是二进制信息，`CPU` 在工作的时候把有的信息看作指令，有的信息看作数据。

`CPU` 将 `CS:IP` 指向的内存单元中的内容看作指令，因为，在任何时候，`CPU` 将 `CS`、`IP` 中的内容当作指令的段地址和偏移地址，用它们合成指令的物理地址，到内存中读取指令码，执行。如果说，内存中的一段信息曾被 `CPU` 执行过的话，那么，它所在的内存单元必然被 `CS:IP` 指向过。

## 2.11 修改 `CS`、`IP` 的指令

在 `CPU` 中，程序员能够用指令读写的部件只有寄存器，程序员可以通过改变寄存器中的内容实现对 `CPU` 的控制。`CPU` 从何处执行指令是由 `CS`、`IP` 中的内容决定的，程序员可以通过改变 `CS`、`IP` 中的内容来控制 `CPU` 执行目标指令。

`8086CPU` 大部分寄存器的值，都可以用 `mov` 指令来改变，`mov` 指令被称为传送指令。

但是，`mov` 指令不能用于设置 `CS`、`IP` 的值，因为 `8086CPU` 没有提供这样的功能。

`8086CPU` 为 `CS`、`IP` 提供了另外的指令来改变它们的值。能够改变 `CS`、`IP` 的内容的指令被统称为转移指令。

一个最简单的可以修改 `CS`、`IP` 的指令: `jmp` 指令。

若想同时修改 `CS`、`IP` 的内容，可用形如 `jmp 段地址:偏移地址` 的指令完成，如:

`jmp 2AE3:3`，执行后: `CS=2AE3H`，`IP=0003H`，`CPU` 将从 `2AE33H` 处读取指令。

`jmp 段地址:偏移地址` 指令的功能为: 用指令中给出的段地址修改 `CS`，偏移地址修改 `IP`。

若想仅修改 `IP` 的内容，可用形如 `jmp 某一合法寄存器` 的指令完成，如:

`jmp ax`，指令执行前: `ax=1000H`，`CS=2000H`，`IP=0003H`。指令执行后: `ax=1000H`，`CS=2000H`，`IP=1000H`。

`jmp 某一合法寄存器` 指令的功能为: 用寄存器中的值修改 `IP`。

`jmp ax`，在含义上类似：`mov IP,ax`。

## 2.12 代码段

对于 `8086PC` 机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将长度为N（`N≤64KB`）的一组代码，存在一组地址连续、起始地址为 `16` 的倍数的内存单元中，我们可以认为，这段内存是用来存放代码的，从而定义了一个代码段。比如，将:

```
mov ax,0000 （B8 00 00）
add ax,0123H （05 23 01）
mov bx,ax（8B D8）
jmp bx （FFE3）
```

这段长度为 `10` 个字节的指令，存放在 `123B0H~123B9H` 的一组内存单元中，这段内存是用来存放代码的，是一个代码段，它的段地址为 `123BH`，长度为 `10` 个字节。

将一段内存当作代码段，仅仅是我们在编程时的一种安排，`CPU` 并不会由于这种安排，就自动地将我们定义的代码段中的指令当作指令来执行。`CPU` 只认被 `CS:IP` 指向的内存单元中的内容为指令。所以，要让 `CPU` 执行我们放在代码段中的指令，必须要将 `CS:IP` 指向所定义的代码段中的第一条指令的首地址。

对于上面的例子，我们将一段代码存放在 `123B0H~123B9H` 内存单元中，将其定义为代码段，如果要让这段代码得到执行，可设 `CS=123BH`、`IP=0000H`。
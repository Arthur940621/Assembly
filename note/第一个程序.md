# 第一个程序

以前都是在 `Debug` 中写一些指令，在 `Debug` 中执行。现在我们将开始编写完整的汇编语言程序，用编译和连接程序将它们编译连接成为可执行文件（如 `*.exe` 文件），在操作系统中运行。

## 一个源程序从写出到执行的过程

![063]()

- 编写汇编源程序:
  - 使用文本编辑器，用汇编语言编写汇编源程序
  - 这一步工作的结果是产生了一个存储源程序的文本文件
- 对源程序进行编译连接:
  - 使用汇编语言编译程序对源程序文件中的源程序进行编译，产生目标文件，再用连接程序对目标文件进行连接，生成可在操作系统中直接运行的可执行文件
  - 可执行文件包含两部分内容:
    - 程序（从源程序中的汇编指令翻译过来的机器码）和数据（源程序中定义的数据）
    - 相关的描述信息（比如，程序有多大、要占用多少内存空间等）
  - 这一步工作的结果:产生了一个可在操作系统中运行的可执行文件
- 执行可执行文件中的程序
  - 在操作系统中，执行可执行文件中的程序
  - 操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化（比如设置 `CS:IP` 指向第一条要执行的指令），然后由 `CPU` 执行程序

## 源程序

下面就是一段简单的汇编语言源程序:

```asm
assume cs:codesg

codesg segment

    mov ax,0123H
    mov bx,0456H
    add ax,bx
    add ax,ax

    mov ax,4c00H
    int 21H

codesg ends

end
```

下面对程序进行说明:

### 伪指令

在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。

汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终为 CPU 所执行。而伪指令没有对应的机器指令，最终不被 CPU 所执行。伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。

程序中出现了 `3` 种伪指令:

```asm
XXX segment
...
XXX ends
```

`segment` 和 `ends` 是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。`segment` 和 `ends` 的功能是定义一个段，`segment` 说明一个段开始，`ends` 说明一个段结束。一个段必须有一个名称来标识，使用格式为:

```asm
段名 segment
...
段名 ends
```

一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。一个源程序中所有将被计算机所处理的信息: 指令、数据、栈，被划分到了不同的段中。一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。

```asm
end
```

end 是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令 end，就结束对源程序的编译。所以，在我们写程序的时候，如果程序写完了，要在结尾处加上伪指令 end。否则，编译器在编译程序时，无法知道程序在何处结束。

```asm
assume
```

这条伪指令的含义为假设。它假设某一段寄存器和程序中的某一个用 `segment...ends` 定义的段相关联。通过 `assume` 说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系。

比如在程序中，用 `codesg segment...codesg ends` 定义了一个名为 `codseg` 的段，在这个段中存放代码，所以这个段是一个代码段。在程序的开头，用 `assume cs:codesg` 将用作代码段的段 `codesg` 和 `CPU` 中的段寄存器 `cs` 联系起来。

### 源程序中的程序

用汇编语言写的源程序，包括伪指令和汇编指令，我们编程的最终目的是让计算机完成一定的任务。源程序中的汇编指令组成了最终由计算机执行的程序，而源程序中的伪指令是由编译器来处理的，它们并不实现编程的最终目的。这里所说的程序就是指源程序中最终由计算机执行、处理的指令或数据。

可以将源程序文件中的所有内容称为源程序，将源程序中最终由计算机执行、处理的指令或数据，称为程序。程序最先以汇编指令的形式存在源程序中，经编译、连接后转变为机器码，存储在可执行文件中。

![064]()

### 标号

汇编源程序中，除了汇编指令和伪指令外，还有一些标号，比如 `codesg`。一个标号指代了一个地址。比如 `codesg` 在 `segment` 的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。

### 程序的结构

通过直接在 `Debug` 中写入汇编指令来写汇编程序，对于十分简短的程序这样做的确方便。可对于大一些的程序，就不能如此了。

我们需要写出能让编译器进行编译的源程序，这样的源程序应该具备起码的结构。

源程序是由一些段构成的。可以在这些段中存放代码、数据，或将某个段当作栈空间。

例如，编程运算 `2^3`:

- 定义一个段，名称为 `abc`

```asm
abc segment
...
abc ends
```

- 在这个段中写入汇编指令，来实现我们的任务

```asm
abc segment

    mov ax,2
    add ax,ax
    add ax,ax

abc ends
```

- 然后，指出程序在何处结束

```asm
abc segment

    mov ax,2
    add ax,ax
    add ax,ax

abc ends

end
```

- abc 被当作代码段来用，所以，应该将 abc 和 cs 联系起来。

```asm
assume cs:abc

abc segment

    mov ax,2
    add ax,ax
    add ax,ax

abc ends

end
```

### 程序返回

我们的程序最先以汇编指令的形式存在源程序中，经编译、连接后转变为机器码，存储在可执行文件中。

一个程序 `P2` 在可执行文件中，则必须有一个正在运行的程序 `Pl`，将 `P2` 从可执行文件中加载入内存后，将 `CPU` 的控制权交给 `P2`，`P2` 才能得以运行。`P2` 开始运行后，`P1` 暂停运行。

而当 `P2` 运行完毕后，应该将 `CPU` 的控制权交还给使它得以运行的程序 `P1`，此后，`Pl` 继续运行。

一个程序结束后，将 `CPU` 的控制权交还给使它得以运行的程序，称这个过程为: 程序返回。

应该在程序的末尾添加返回的程序段。

```asm
mov ax,4c00H
int 21H
```

这两条指令所实现的功能就是程序返回。


|目的|相关指令|指令性质|指令执行者|
|-|-|-|-|
|通知编译器一个段结束|段名 ends|伪指令|编译时，由编译器执行|
|通知编译器程序结束|end|伪指令|编译时，由编译器执行|
|程序返回|mov ax,4c00H int 21H|汇编指令|执行时，由 CPU 执行|

### 语法错误和逻辑错误

一般说来，程序在编译时被编译器发现的错误是语法错误。

在源程序编译后，在运行时发生的错误是逻辑错误。

语法错误容易发现，也容易解决。而逻辑错误通常不容易被发现。

## 编辑源程序

可以用任意的文本编辑器来编辑源程序，只要最终将其存储为纯文本文件即可。

将程序保存为文件 `c:\1.asm`。

![065]()

## 编译

完成对源程序的编辑后，得到一个源程序文件 `c:\1.asm`。可以对其进行编译，生成包含机器代码的目标文件。

在编译一个源程序之前首先要找到一个相应的编译器。这里采用微软的 `masm` 汇编编译器，文件名为 `masm.exe`。

![066]()

运行 `masm` 后，首先显示出一些版本信息，然后提示输入将要被编译的源程序文件的名称。`[.ASM]` 提示我们，默认的文件扩展名是 `asm`。如果源程序文件不是以 `asm` 为扩展名的话，就要输入它的全名。

在输入源程序文件名的时候要指明它所在的路径。如果文件就在当前路径下，只输入文件名就可以，如果文件在其他的目录中，则要输入路径。

![067]()

在输入源程序文件名后，程序继续提示我们输入要编译出的目标文件的名称，目标文件是我们对一个源程序进行编译得到的最终结果。`[1.OBJ]` 因为我们已经输入了源程序文件名为 `1.asm`，则编译程序默认要输出的目标文件名为 `1.obj`，所以可以不必再另行指定文件名。也可以指定生成的目标文件所在的目录。

![068]()

编译程序提示输入列表文件的名称，这个文件是编译器将源程序编译为目标文件的过程中产生的中间结果。可以让编译器不生成这个文件。

![069]()

编译程序提示输入交叉引用文件的名称，这个文件同列表文件一样，是编译器将源程序编译为目标文件过程中产生的中间结果。可以让编译器不生成这个文件。

![070]()

对源程序的编译结束，编译器输出的最后两行告诉我们这个源程序没有警告错误和必须要改正的错误。

按照上面的过程进行了编译之后，在编译器 `masm.exe` 运行的目录下，将出现一个新的文件: `1.obj`，这是对源程序 `1.asm` 进行编译所得到的结果。

如果编译的过程中出现错误，那么将得不到目标文件。一般来说，有两类错误使我们得不到所期望的目标文件:
- 程序中有` Severe Errors`
- 找不到所给出的源程序文件

在编译的过程中，我们提供了一个输入，即源程序文件。最多可以得到 `3` 个输出:
- 目标文件（`.obj`）
- 列表文件（`.lst`）
- 交叉引用文件（`.crf`）

这 `3` 个输出文件中，目标文件是我们最终要得到的结果，而另外两个只是中间结果，可以让编译器忽略对它们的生成。

### 连接

在对源程序进行编译得到目标文件后，需要对目标文件进行连接，从而得到可执行文件。

`1.asm` 进行编译得到 `1.obj`，再将` 1.obj` 连接为 `1.exe`。

使用微软的 `Overlay Linker` 连接器，文件名为 `link.exe`。

![071]()

运行 `link` 后，首先显示出一些版本信息，然后提示输入将要被连接的目标文件的名称。`[.OBJ]` 提示我们默认的文件扩展名是 `obj`，如果文件不是以 `obj` 为扩展名，就要输入它的全名。

![072]()

在输入目标文件名后，程序继续提示我们输入要生成的可执行文件的名称，可执行文件是我们对一个程序进行连接要得到的最终结果。`[1.EXE]` 是程序默认要输出的可执行文件名，可以不必再另行指定文件名。编译程序将在当前的目录下，生成 `1.EXE` 文件。也可以指定生成的可执行文件所在的目录。

![073]()

连接程序提示输入映像文件的名称，这个文件是连接程序将目标文件连接为可执行文件过程中产生的中间结果，可以让连接程序不生成这个文件。

![074]()

忽略了映像文件的生成后，连接程序提示输入库文件的名称。库文件里面包含了一些可以调用的子程序，如果程序中调用了某一个库文件中的子程序，就需要在连接的时候，将这个库文件和目标文件连接到一起，生成可执行文件。但是，这个程序中没有调用任何子程序，所以，这里忽略库文件名的输入。

![075]()

对目标文件的连接结束，连接程序输出的最后一行告诉我们这个程序中有一个警告错误: 没有栈段，这里我们不理会这个错误。

上面通过对 `1.obj` 进行连接的过程，展示了使用连接器对目标文件进行连接的方法。按照上面的过程进行了连接之后，在连接器 `link.exe` 运行的目录下将出现一个新的文件: `1.exe`，这是对目标文件 `1.obj` 进行连接所得到的结果。

简单地讲连接的作用，连接的作用有以下几个:
- 当源程序很大时，可以将它分为多个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将它们连接到一起，生成一个可执行文件
- 程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件
- 一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目
标文件进行处理，生成可执行文件

对于连接的过程，可执行文件是我们要得到的最终结果。

## 以简化的方式进行编译和连接

编译、连接的最终目的是用源程序文件生成可执行文件。在这个过程中所产生的中间文件都可以忽略。可以用一种较为简捷的方式进行编译、连接:

![076]()

在 `masm` 后面加上被编译的源程序文件的路径、文件名，在命令行的结尾再加上分号，在当前路径下生成目标文件 `.obj`，并在编译的过程中自动忽略中间文件的生成。

![077]()

在 `link` 后面加上被连接的目标文件的路径、文件名，在命令行的结尾再加上分号，连接程序就对当前路径下的 `.obj` 进行处理，在当前路径下生成可执行文件 `.exe`，并在过程中自动忽略中间文件的生成。

## `.exe` 的执行

![078]()

程序运行后，没有任何结果，就和没有运行一样。程序当然是运行了，只是从屏幕上不可能看到任何运行结果，因为，我们的程序根本没有向显示器输出任何信息。程序只是做了一些将数据送入寄存器和加法的操作，而这些事情，不可能从显示屏上看出来。程序执行完成后，返回，屏幕上再次出现操作系统的提示符。

## 谁将可执行文件中的程序装载进入内存并使它运行？

在 `DOS` 中，可执行文件中的程序 `P1` 若要运行，必须有一个正在运行的程序 `P2`，将 `P1` 从可执行文件中加载入内存，将 `CPU` 的控制权交给它，`Pl` 才能得以运行；当 `P1` 运行完毕后，应该将 `CPU` 的控制权交还给使它得以运行的程序 `P2`。

### 操作系统的外壳

操作系统是由多个功能模块组成的庞大、复杂的软件系统。任何通用的操作系统，都要提供一个称为 `shell` 的程序，用户使用这个程序来操作计算机系统进行工作。

`DOS` 中有一个程序 `command.com`，这个程序在 `DOS` 中称为命令解释器，也就是 `DOS` 系统的 `shell`。

`DOS` 启动时，先完成其他重要的初始化工作，然后运行 `command.com`，`command.com` 运行后，执行完其他的相关任务后，在屏幕上显示出由当前盘符和当前路径组成的提示符，然后等待用户的输入。

用户可以输入所要执行的命令，比如 `cd`、`dir`、`type` 等，这些命令由 `command` 执行，`command` 执行完这些命令后，再次显示由当前盘符和当前路径组成的提示符，等待用户的输入。

如果用户要执行一个程序，则输入该程序的可执行文件的名称，`command` 首先根据文件名找到可执行文件，然后将这个可执行文件中的程序加载入内存，设置 `CS:IP` 指向程序的入口。此后，`command` 暂停运行，`CPU` 运行程序。程序运行结束后，返回到 `command` 中，`command` 再次显示由当前盘符和当前路径组成的提示符，等待用户的输入。

在 `DOS` `中，command` 处理各种输入: 命令或要执行的程序的文件名。

- 在 `DOS` 中直接执行 `1.exe` 时，是正在运行的 `command`，将 `1.exe` 中的程序加载入内存
- `command` 设置 `CPU` 的 `CS:IP` 指向程序的第一条指令，从而使程序得以运行
- 程序运行结束后，返回到 `command` 中，`CPU` 继续运行 `command`

### 汇编程序从写出到执行的过程

`编程(Edit)→1.asm→编译(masm)→1.obj→连接(link)→1.exe→加载(command)→内存中的程序→运行(CPU)`

## 程序执行过程的跟踪

可以用 `Debug` 来跟踪一个程序的运行过程。

在 `DOS` 中运行一个程序的时候，是由 `command` 将程序从可执行文件中加载入内存，并使其得以执行。但是，这样不能逐条指令地看到程序的执行过程，因为 `command` 的程序加载，设置 `CS:IP` 指向程序的入口的操作是连续完成的，而当 `CS:IP` 一指向程序的入口，`command` 就放弃了 `CPU` 的控制权，`CPU` 立即开始运行程序，直至程序结束。

为了观察程序的运行过程，可以使用 `Debug`。`Debug` 可以将程序加载入内存，设置 `CS:IP` 指向程序的入口，但 `Debug` 并不放弃对 `CPU` 的控制，这样，可以使用 `Debug` 的相关命令来单步执行程序，查看每一条指令的执行结果。

在提示符后输入 `debug 1.exe`，`Debug` 将程序从 `1.exe` 中加载入内存，进行相关的初始化后设置 `CS:IP` 指向程序的入口。可以用 `R` 命令看一下各个寄存器的设置情况:

![079]()

`Debug` 将程序从可执行文件加载入内存后，`cx` 中存放的是程序的长度。`1.exe` 中程序的机器码共有 `15` 个字节。则 `1.exe` 加载后，`cx` 中的内容为 `000FH`。

`DOS` 系统中 `.EXE` 文件中的程序的加载过程:

![080]()

有一步称为重定位的工作在图中没有讲解，因为这个问题和操作系统的关系较大，不作讨论。

那么，程序被装入内存的什么地方？
- 程序加载后，`ds` 中存放着程序所在内存区的段地址，这个内存区的偏移地址为 `0`，则程序所在的内存区的地址为 `ds:0`
- 这个内存区的前 `256` 个字节中存放的是 `PSP`，`DOS` 用来和程序进行通信。从 `256` 字节处向后的空间存放的是程序

所以，从 `ds` 中可以得到 `PSP` 的段地址 `SA`，`PSP` 的偏移地址为 `0`，则物理地址为 `SA*16+0`。

因为 `PSP` 占 `256`（`100H`）字节，所以程序的物理地址是:

`SA*16+0+256=SA*16+16×16+0=(SA+16)*16+0`

可用段地址和偏移地址表示为: `SA+10H:0`。

`DS=075A`，则 `PSP` 的地址为 `075A:0`，程序的地址为 `076A:0000`（即 `075A+10:0`)。

`CS=075A`，`IP=0000`，`CS:IP` 指向程序的第一条指令。注意，源程序中的指令是 `mov ax,0123H`，在 `Debug` 中记为 `mov ax,0123`，这是因为 `Debug` 默认所有数据都用十六进制表示。

用 `U` 命令看一下其他指令:

![081]()

用 `T` 命令单步执行程序中的每一条指令到了 `int 21`，用 `P` 命令执行:

![082]()

在 `DOS` 中运行程序时，是 `command` 将程序加载入内存，所以程序运行结束后返回到 `command` 中，而在这里是 `Debug` 将程序加载入内存，所以程序运行结束后要返回到 `Debug` 中。

使用 `Q` 命令退出 `Debug`，将返回到 `command` 中，因为 `Debug` 是由 `command` 加载运行的。

在 `DOS` 中用 `debug 1.exe` 运行 `Debug` 对 `1.exe` 进行跟踪时，程序加载的顺序是:
- `command` 加载 `Debug`，`Debug` 加载 `1.exe`

返回的顺序是:
- 从 `1.exe` 中的程序返回到 `Debug`，从 `Debug` 返回到 `command`
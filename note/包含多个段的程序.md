# 包含多个段的程序

如果程序需要用其他空间来存放数据，使用哪里呢？

`0:200~0:2FF` 是相对安全的，可这段空间的容量只有 `256` 个字节，如果我们需要的空间超过 `256` 个字节该怎么办呢？

在操作系统的环境中，合法地通过操作系统取得的空间都是安全的，因为操作系统不会让一个程序所用的空间和其他程序以及系统自己的空间相冲突。在操作系统允许的情况下，程序可以取得任意容量的空间。

程序取得所需空间的方法有两种:
- 加载程序的时候为程序分配
- 程序在执行的过程中向系统申请

加载程序的时候为程序分配空间，比如我们的程序在加载的时候，取得了代码段中的代码的存储空间。

我们若要一个程序在被加载的时候取得所需的空间，则必须要在源程序中做出说明。通过在源程序中定义段来进行内存空间的获取。

上面是从内存空间获取的角度上，谈定义段的问题。再从程序规划的角度来谈一下定义段的问题。大多数有用的程序，都要处理数据，使用栈空间，当然也都必须有指令，为了程序设计上的清晰和方便，一般也都定义不同的段来存放它们。

## 在代码段中使用数据

考虑这样一个问题，编程计算以下 `8` 个数据的和，结果存在 `ax` 寄存器中:

```
0123h、0456h、0789h、0abch、0defh、0fedh、0cbah、0987h
```

之前都是累加某些内存单元中的数据，并不关心数据本身。可现在要累加的就是已经给定了数值的数据。我们可以将它们一个一个地加到 `ax` 寄存器中，但是，我们希望可以用循环的方法来进行累加，所以在累加前，要将这些数据存储在一组地址连续的内存单元中。

- 如何将这些数据存储在一组地址连续的内存单元中呢？
  - 可以用指令一个一个地将它们送入地址连续的内存单元中。
- 到哪里去找这段内存空间呢？
  - 从规范的角度来讲，我们是不能自己随便决定哪段空间可以使用的，应该让系统来为我们分配。我们可以在程序中，定义我们希望处理的数据，这些数据就会被编译、连接程序作为程序的一部分写到可执行文件中。当可执行文件中的程序被加载入内存时，这些数据也同时被加载入内存中。与此同时，我们要处理的数据也就自然而然地获得了存储空间。

```asm
assume cs:code
code segment

    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h

    mov bx,0
    mov ax,0

    mov cx,8
  s:add ax,cs:[bx]
    add bx,2
    loop s

    mov ax,4c00h
    int 21h

code ends
end
```

程序第一行中的 `dw` 的含义是定义字型数据。即 `define word`。

在这里，使用 `dw` 定义了 `8` 个字型数据，数据之间以逗号分隔，它们所占的内存空间的大小为 `16` 个字节。

程序中的指令就要对这 `8` 个数据进行累加，由于它们在代码段中，程序在运行的时候 `CS` 中存放代码段的段地址，所以可以从 `CS` 中得到它们的段地址。因为用 `dw` 定义的数据处于代码段的最开始，所以偏移地址为 0，这 8 个数据就在代码段的偏移 `0`、`2`、`4`、`6`、`8`、`A`、`C`、`E` 处。程序运行时，它们的地址就是 `CS:0`、`CS:2`、`CS:4`、`CS:6`、`CS:8`、`CS:A`、`CS:C`、`CS:E`。

程序中，用 `bx` 存放加 `2` 递增的偏移地址，用循环来进行累加。在循环开始前，设置 `(bx)=0`，`cs:bx` 指向第一个数据所在的字单元。每次循环中 `(bx)=(bx)+2`，`cs:bx` 指向下一个数据所在的字单元。

![108]()

图中，通过 `DS=075A`，可知道程序从 `076A:0000` 开始存放。用 `u` 命令从 `076A:0000` 查看程序，却看到了一些让人读不懂的指令。

实际上用 `u` 命令从 `076A:0000` 查看到的也是程序中的内容，只不过不是源程序中的汇编指令所对应的机器码，而是源程序中，在汇编指令前面，用 `dw` 定义的数据。实际上，在程序中，有一个代码段，在代码段中，前面的 `16` 个字节是用 `dw` 定义的数据，从第 `16` 个字节开始才是汇编指令所对应的机器码。

可以用 `d` 命令更清楚地查看一下程序中前 `16` 个字节的内容:

![109]()

可以从 `076A:0010` 查看程序中要执行的机器指令

![110]()

怎样执行程序中的指令呢？用 `Debug` 加载后，可以将 `IP` 设置为 `10h`，从而使 `CS:IP` 指向程序中的第一条指令。然后再用 `t` 命令、`p` 命令，或者是 `g` 命令执行。

可是这样一来，我们就必须用 `Debug` 来执行程序，在系统中直接运行可能会出现问题，因为程序的入口处不是我们所希望执行的指令。

我们可以在源程序中指明程序的入口所在:

```asm
assume cs:code
code segment

    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h

    start:  mov bx,0
            mov ax,0

            mov cx,8
    s:      add ax,cs:[bx]
            add bx,2
            loop s

            mov ax,4c00h
            int 21h

code ends
end start
```

在程序的第一条指令的前面加上了一个标号 `start`，而这个标号在伪指令 `end` 的后面出现。

`end` 除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。在程序中我们用 `end` 指令指明了程序的入口在标号 `start` 处，也就是说，`mov bx,0` 是程序的第一条指令。

在单任务系统中，可执行文件中的程序执行过程如下:
- 由其他的程序（`Debug`、`command`或其他程序）将可执行文件中的程序加载入内存
- 设置 `CS:IP` 指向程序的第一条要执行的指令（即程序的入口），从而使程序得以运行
- 程序运行结束后，返回到加载者

- 如何知道哪一条指令是程序的第一条要执行的指令？
  - 由可执行文件中的描述信息指明

我们知道可执行文件由描述信息和程序组成:
- 程序来自于源程序中的汇编指令和定义的数据
- 描述信息则主要是编译、连接程序对源程序中相关伪指令进行处理所得到的信息。

在程序中，用伪指令 `end` 描述了程序的结束和程序的入口。在编译、连接后，由 `end start` 指明的程序入口，被转化为一个入口地址，存储在可执行文件的描述信息中。

在程序生成的可执行文件中，这个入口地址的偏移地址部分为 `10H`。当程序被加载入内存之后，加载者从程序的可执行文件的描述信息中读到程序的入口地址，设置 `CS:IP`。这样 `CPU` 就从我们希望的地址处开始执行。

归根结底，我们若要 `CPU` 从何处开始执行程序，只要在源程序中用 `end 标号` 指明就可以了。

程序框架:

```asm
assume cs:code
code segment
    ......
    数据
    ......
start:
    ......
    代码
    ......
code ends
end start
```

## 在代码段中使用栈

完成下面的程序，利用栈，将程序中定义的数据逆序存放:

```asm
assume cs:codesg
codesg segment
    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
    ?
codesg ends
end
```

程序的思路大致如下:

程序运行时，定义的数据存放在 `cs:0~cs:F` 单元中，共 `8` 个字单元。依次将这 `8` 个字单元中的数据入栈，然后再依次出栈到这 `8` 个字单元中，从而实现数据的逆序存放。

首先要有一段可当作栈的内存空间。这段空间应该由系统来分配。可以在程序中通过定义数据来取得一段空间，然后将这段空间当作栈空间来用。程
序如下:

```asm
assume cs:codesg
codesg segment
    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
    dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    ;用 dw 定义 16 个字型数据，在程序加载后，将取得 16 个字的内存空间，存放这 16 个数据。在后面的程序中将这段空间当作栈来使用

    start:  mov ax,cs
            mov ss,ax
            mov sp,30h  ;将设置栈顶 ss:sp 指向 cs:30

            mov bx,0
            mov cx,8
        s:  push cs:[bx]
            add bx,2
            loop s      ;以上将代码段 0~15 单元中的 8 个字型数据依次入栈

            mov bx,0
            mov cx,8
        s0: pop cs:[bx]
            add bx,2
            loop s0     ;以上依次出栈 8 个字型数据到代码段 0~15 单元中
            
            mov ax,4c00h
            int 21h
codesg ends
end start               ;指明程序的入口在 start 处
```

我们要将 `cs:10~cs:2F` 的内存空间当作栈来用，初始状态下栈为空，所以 `ss:sp` 要指向栈底，则设置 `ss:sp` 指向 `cs:30`。

计算方法:

`8+16=24` 个字形数据，`48` 个字节，偏移位置为 `0~47`，栈底再偏移一个位置为 `48=30H`。

在代码段中定义了 `16` 个字型数据，它们的数值都是 `0`。这 `16` 个字型数据的值是多少，对程序来说没有意义。我们用 `dw` 定义 `16` 个数据，即在程序中写入了 `16` 个字型数据，而程序在加载后，将用 `32` 个字节的内存空间来存放它们。这段内存空间是我们所需要的，程序将它用作栈空间。

我们定义这些数据的最终目的是，通过它们取得一定容量的内存空间。所以我们在描述 `dw` 的作用时，可以说用它定义数据，也可以说用它开
辟内存空间。比如对于:

```
dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
```

可以说，定义了 `8` 个字型数据，也可以说，开辟了 `8` 个字的内存空间。

## 将数据、代码、栈放入不同的段

程序中用到了数据和栈，将数据、栈和代码都放到了一个段里面。我们在编程的时候要注意何处是数据，何处是栈，何处是代码。这样做显然有两个问题:
- 把它们放到一个段中使程序显得混乱
- 前面程序中处理的数据很少，用到的栈空间也小，加上没有多长的代码，放到一个段里面没有问题。但如果数据、栈和代码需要的空间超过 `64KB`，就不能放在一个段中（`8086` 模式的限制）
  - 注: `8086` 有 `20` 跟地址总线，可寻址 `2^20 = 1048576` 个内存单元，每个内存单元为 `1` 字节，即最大可寻址 `1048576 Byte/1024/1024 = 1 MB`，偏移地址为 16 位，一个段最大为 `2^16 Byte = 64 KB`


所以，应该考虑用多个段来存放数据、代码和栈。用和定义代码段一样的方法来定义多个段，然后在这些段里面定义需要的数据，或通过定义数据来取得栈空间。具体做法如下面的程序所示:

```asm
assume cs:code,ds:data,ss:stack
data segment
    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
data ends
stack segment
    dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
stack ends
code segment
start:  mov ax,stack
        mov ss,ax
        mov sp,20h  ;设置栈顶 ss:sp 指向 stack:20
        mov ax,data
        mov ds,ax   ;ds 指向 data 段
        mov bx,0    ;ds:bx 指向 data 段中的第一个单元
        mov cx,8
s:      push[bx]
        add bx,2
        loop s      ;以上将 data 段中的 0~15 单元中的 8 个字型数据依次入栈
        mov bx,0
        mov cx,8
s0:     pop[bx]
        add bx,2
        loop s0     ;以上依次出栈 8 个字型数据到 data 段的 0~15 单元中
        mov ax,4c00h
        int 21h
code ends
end start
```

- 定义多个段的方法
  - 定义一个段的方法和前面定义代码段的方法没有区别，只是对于不同的段，要有不同的段名
- 对段地址的引用
  - 现在，程序中有多个段了，通过地址访问段中的数据，而地址是分为两部分的，即段地址和偏移地址。在程序中，段名就相当于一个标号，它代表了段地址。所以指令 `mov ax,data` 的含义就是将名称为 `data` 的段的段地址送入 `ax`。一个段中的数据的段地址可由段名代表，偏移地址看它在段中的位置。程序中 `data` 段中的数据 `0abch` 的地址就是: `data:6`。要将它送入 `bx` 中，如下代码:
  
    ```asm
    mov ax,data
    mov ds,ax
    mov bx,ds:[6]
    ```
    我们不能用下面的指令:
    
    ```asm
    mov ds,data
    mov bx,ds[6]
    ```

    其中指令 `mov ds,data` 是错误的，因为 `8086CPU` 不允许将一个数值直接送入段寄存器中。程序中对段名的引用，如指令 `mov ds,data` 中的 `data`，将被编译器处理为一个表示段地址的数值
- 代码段、数据段、栈段完全是我们的安排
  - 现在，我们以一个具体的程序来再次讨论一下所谓的代码段、数据段、栈段。在汇编源程序中，可以定义许多的段，比如在上面的程序中，定义了 `3` 个段，`code`、`data` 和 `stack`。我们可以分别安排它们存放代码、数据和栈
    - 我们在源程序中为这 `3` 个段起了具有含义的名称，用来放数据的段我们将其命名为 `data`，用来放代码的段我们将其命名为 `code`，用作栈空间的段命名为 `stack`。我们这样命名，仅仅是为了使程序便于阅读。这些名称同 `start`、`s`、`s0` 等标号一样，仅在源程序中存在，`CPU` 并不知道它们
    - 我们在源程序中用伪指令 `assume cs:code`，`ds:data`，`ss:stack` 将 `cs`、`ds` 和 `ss` 分别和 `code`、`data`、`stack` 段相连。`assume` 是伪指令，是由编译器执行的，也是仅在源程序中存在的信息，`CPU` 并不知道它们。仅仅用它将定义的具有一定用途的段和相关的寄存器联系起来
    - 若要 `CPU` 按照我们的安排行事，就要用机器指令控制它，源程序中的汇编指令是 `CPU` 要执行的内容。源程序的最后用 `end start` 说明了程序的入口，这个入口将被写入可执行文件的描述信息，可执行文件中的程序被加载入内存后，`CPU` 的 `CS:IP` 被设置指向这个入口，从而开始执行程序中的第一条指令。标号 `start` 在 `code` 段中，这样 `CPU` 就将 `code` 段中的内容当作指令来执行了。在 `code` 段中，使用指令:

      ```asm
      mov ax,stack
      mov ss,ax
      mov sp,20h
      ```

      设置 `ss` 指向 `stack`，设置 `ss:sp` 指向 `stack:20`，`CPU` 执行这些指令后，将把 `stack` 段当做栈空间来用。`CPU` 若要访问 `data` 段中的数据，则可用 `ds` 指向 `data` 段，用其他的寄存器（如 `bx`）来存放 `data` 段中数据的偏移地址。
- 总之，CPU 到底如何处理我们定义的段中的内容，是当作指令执行，当作数据访问，还是当作栈空间，完全是靠程序中具体的汇编指令，和汇编指令对 `CS:IP`、`SS:SP`、`DS` 等寄存器的设置来决定的:

```asm
assume cs:b,ds:a,ss:c
a segment
    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
a ends
c segment
    dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
c ends
b segment
d:      mov ax,c
        mov ss,ax
        mov sp,20h  ;希望用 c 段当作栈空间，设置ss:sp指向c:20
        mov ax,a
        mov ds,ax   ;希望用 ds:bx 访问 a 段中的数据，ds 指向 a 段
        mov bx,0    ;ds:bx 指向 a 段中的第一个单元
        mov cx,8
s:      push[bx]
        add bx,2
        loop s      ;以上将 a 段中的 0~15 单元中的 8 个字型数据依次入栈
        mov bx,0
        mov cx,8
s0:     pop[bx]
        add bx,2
        loop s0     ;以上依次出栈 8 个字型数据到 a 段的 0~15 单元中
        mov ax,4c00h
        int 21h
b ends
end d
```



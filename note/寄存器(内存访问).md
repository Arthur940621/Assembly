# 第三章 寄存器(内存访问)

## 内存中字的存储

`CPU` 中，用 `16` 位寄存器来存储一个字。高 `8` 位存放高位字节，低 `8` 位存放低位字节。在内存中存储时，由于内存单元是字节单元，则一个字要用两个地址连续的内存单元来存放。

例如从 `0` 地址开始存放 `20000`:

![047]()

在图中，用 `0`、`1` 两个内存单元存放数据 `20000`（`4E20H`）。`0`、`1` 两个内存单元用来存储一个字，这两个单元可以看作一个起始地址为 `0` 的字单元。对于这个字单元来说，`0` 号单元是低地址单元，`1` 号单元是高地址单元。

同理，将 `2`、`3` 号单元看作一个字单元，它的起始地址为 `2`。在这个字单元中存放数据 `18`（`0012H`），则在 `2` 号单元中存放低位字节 `12H`，在 `3` 号单元中存放高位字节 `00H`。

字单元的概念: 字单元，即存放一个字型数据（`16` 位）的内存单元，由两个地址连续的内存单元组成。高地址内存单元中存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。

任何两个地址连续的内存单元，`N` 号单元和 `N+1` 号单元，可以将它们看成两个内存单元，也可看成一个地址为 `N` 的字单元中的高位字节单元和低位字节单元。

## `DS` 和 `[address]`

`CPU` 要读写一个内存单元的时候，必须先给出这个内存单元的地址，在 `8086PC` 中，内存地址由段地址和偏移地址组成。

`8086CPU` 中有一个 `DS` 寄存器，通常用来存放要访问数据的段地址。比如要读取 `10000H` 单元的内容，可以用如下的程序段进行。

```asm
mov bx,1000H
mov ds,bx
mov al,[0]
```

上面的 `3` 条指令将 `10000H`（`1000:0`）中的数据读到 `al` 中。

`mov` 指令，可完成两种传送:
- 将数据直接送入寄存器
- 将一个寄存器中的内容送入另一个寄存器

也可以使用 `mov` 指令将一个内存单元中的内容送入一个寄存器中。在指令中必须指明从哪一个内存单元送到哪一个寄存器中。寄存器用寄存器名来指明，内存单元需用内存单元的地址来指明。

显然，此时 `mov` 指令的格式应该是: `mov 寄存器名,内存单元地址`。

`[…]` 表示一个内存单元，`[…]` 中的 `0` 表示内存单元的偏移地址。但是只有偏移地址是不能定位一个内存单元的。指令执行时，`8086CPU` 自动取 `ds` 中的数据为内存单元的段地址。

`10000H` 用段地址和偏移地址表示为 `1000:0`，先将段地址 `1000H` 放入 `ds`，然后用 `mov al,[0]` `完成传送。mov` 指令中的 `[]` 说明操作对象是一个内存单元，`[]` 中的 `0` 说明这个内存单元的偏移地址是 `0`，它的段地址默认放在 `ds` 中，指令执行时，`8086CPU` 会自动从 `ds` 中取出。

把一个数据送入寄存器以前用类似 `mov ax,1` 这样的指令来完成，从理论上讲，我们可以用相似的方式: `mov ds,1000H`，来将 `1000H` 送入 `ds`。

但是，`8086CPU` 不支持将数据直接送入段寄存器的操作，只能用一个寄存器来进行中转，即先将 `1000H` 送入一个一般的寄存器，如 `bx`，再将 `bx` 中的内容送入 `ds`。

从内存单元到寄存器的格式是: `mov 寄存器名,内存单元地址`，从寄存器到内存单元则是: `mov 内存单元地址,寄存器名`。

## 字的传送

因为 `8086CPU` 是 `16` 位结构，有 `16` 根数据线，所以，可以一次性传送 `16` 位的数据，也就是说可以一次性传送一个字。只要在 `mov` 指令中给出 `16` 位的寄存器就可以进行 `16` 位数据的传送了。

```asm
mov bx,1000H
mov ds,bx
mov ax,[0]  ;1000:0 处的字型数据送入 ax
mov [0],cx  ;cx 中的 16 位数据送到 1000:0 处
```

举个例子:

```asm
mov ax,1000H
mov ds,ax
mov ax,[0]
mov bx,[2]
mov cx,[1]
add bx,[1]
add cx,[2]
```

内存情况示意:

![048]()

进行单步跟踪:

![049]()

```asm
mov ax,1000H
mov ds,ax
mov ax,11316
mov [0],ax
mov bx,[0]
sub bx,[2]
mov [2],bx
```

内存情况示意:

![050]()

进行单步跟踪:

![051]()

## `mov`、`add`、`sub` 指令

前面用到了 `mov`、`add`、`sub` 指令，它们都带有两个操作对象。


`mov` 指令可以有以下几种形式:
- `mov 寄存器,数据`，比如: `mov ax,8`
- `mov 寄存器,寄存器`，比如: `mov ax,bx`
- `mov 寄存器,内存单元`，比如: `mov ax,[0]`
- `mov 内存单元,寄存器`，比如: `mov[0],ax`
- `mov 段寄存器,寄存器`，比如: `mov ds,ax`

既然有 `mov 段寄存器,寄存器`，从寄存器向段寄存器传送数据，那么也应该有 `mov 寄存器,段寄存器`，从段寄存器向寄存器传送数据。

一个合理的设想是: `8086CPU` 内部有寄存器到段寄存器的通路，那么也应该有相反的通路。

![052]()

段寄存器 `ds` 中的值送到了寄存器 `ax` 中。`mov 寄存器,段寄存器` 是正确的指令。

既然有 `mov 内存单元,寄存器`，从寄存器向内存单元传送数据，那么也应该有 `mov 内存单元,段寄存器`，从段寄存器向内存单元传送数据。比如我们可以将段寄存器 `cs` 中的内容送入内存 `10000H` 处:

```asm
mov ax,1000H
mov ds,ax
mov [0],cs
```

![053]()

当执行 `mov [0],cs` 前的时候，`Debug` 显示当前的指令 `mov [0000],cs`，因为这是一条访问内存的指令，`Debug` 还显示出指令要访问的内存单元中的内容。由于指令中的 `CS` 是一个 `16` 位寄存器，所以要访问的内存单元是一个字单元，它的偏移地址为 `0`，段地址在 `ds` 中，`Debug` 在屏幕右边显示出 `DS:0000-0000`，我们可以知道这个字单元中的内容为 `0`。

`mov 段寄存器,内存单元` 也应该可行，比如我们可以用 `10000H` 处存放的字型数据设置 `ds`（即将 `10000H` 处存放的字型数据送入 `ds`），指令如下:

```asm
mov ax,1000H
mov ds,ax
mov ds,[0]
```

![054]()

`add` 和 `sub` 指令同 `mov` 一样，都有两个操作对象:
- `add 寄存器,数据`，比如: `add ax,8`
- `add 寄存器,寄存器`，比如: `add ax,bx`
- `add 寄存器,内存单元`，比如: `add ax,[0]`
- `add 内存单元,寄存器`，比如: `add [0],ax`
- `sub 寄存器,数据`，比如: `sub ax,9`
- `sub 寄存器,寄存器`，比如: `sub ax,bx`
- `sub 寄存器,内存单元`，比如: `sub ax,[0]`
- `sub 内存单元,寄存器`，比如: `sub [0],ax`

## 数据段

对于 `8086PC` 机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将一组长度为 `N`（`N≤64KB`）、地址连续、起始地址为 `16` 的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段。

解释:

因为 **物理地址=基础地址+偏移地址=段地址*16+偏移地址**

长度为 `N`（`N≤64KB`），是因为偏移地址使用一个 `16` 位的二进制数表示，其表示范围是 `0000H:FFFFH`。总共有 `2^16=64K` 个不同的取值，故一个段的大小是 `64K`。

起始地址为 `16` 的倍数，是因为`基础地址=段地址*16`。

比如 `123B0H~123B9H` 这段内存空间来存放数据，我们就可以认为，`123B0H~123B9H` 这段内存是一个数据段，它的段地址为 `123BH`，长度为 `10` 个字节。

访问数据段中的数据，可以将一段内存当作数据段，在具体操作的时候，用 `ds` 存放数据段的段地址，再根据需要，用相关指令访问数据
段中的具体单元。

比如，将 `123B0H~123B9H` 的内存单元定义为数据段。现在要累加这个数据段中的前 `3` 个单元中的数据:

```asm
mov ax,123BH
mov ds,ax   ;将 123BH 送入 ds 中,作为数据段的段地址
mov al,0    ;用 al 存放累加结果
add al,[0]  ;将数据段第一个单元（偏移地址为 0）中的数值加到 al 中
add al,[1]  ;将数据段第二个单元（偏移地址为 1）中的数值加到 al 中
add al,[2]  ;将数据段第三个单元（偏移地址为 2）中的数值加到 al 中
```

如果加到 `ax` 中时，一个字型数据占两个单元，所以偏移地址是 `0`、`2`、`4`。

```asm
mov ax,123BH
mov ds,ax   ;将 123BH 送入 ds 中,作为数据段的段地址
mov ax,0    ;用 ax 存放累加结果
add ax,[0]  ;将数据段第一个字（偏移地址为 0）中的数值加到 ax 中
add ax,[2]  ;将数据段第二个单元（偏移地址为 2）中的数值加到 ax 中
add ax,[4]  ;将数据段第三个单元（偏移地址为 4）中的数值加到 ax 中
```

## 栈

栈是一种具有特殊的访问方式的存储空间。它的特殊性就在于，最后进入这个空间的数据，最先出去。

从程序化的角度来讲，应该有一个标记，这个标记一直指示着栈顶。

栈有两个基本的操作: 入栈和出栈。
- 入栈就是将一个新的元素放到栈顶
- 出栈就是从栈顶取出一个元素

栈顶的元素总是最后入栈，需要出栈时，又最先被从栈中取出。栈的这种操作规则被称为: `LIFO`（`Last In First Out`，后进先出）。

## `CPU` 提供的栈机制

现今的 `CPU` 中都有栈的设计。`8086CPU` 提供相关的指令来以栈的方式访问内存空间，可以将一段内存当作栈来使用。

`8086CPU` 提供入栈和出栈指令，最基本的两个是 `PUSH` 入栈和 `POP` 出栈。

比如，`push ax` 表示将寄存器 `ax` 中的数据送入栈中，`pop ax` 表示从栈顶取出数据送入 `ax`。

`8086CPU` 的入栈和出栈操作都是以字为单位进行的。

例如，将 `10000H~1000FH` 这段内存当作栈来使用。

![055]()

```asm
mov ax,0123H
push ax
mov bx,2266H
push bx
mov cx,1122H
push cx
pop ax
pop bx
pop cx
```

字型数据用两个单元存放，高地址单元存放高 `8` 位，低地址单元存放低 `8` 位。

有两个问题:
- 其一，`CPU` 执行 `push` 和 `pop` 指令时，将对这段空间按照栈的后进先出的规则进行访问。但是 `CPU` 如何知道 `10000H~1000FH` 这段空间被当作栈来使用？
- 其二，`push ax` 等入栈指令执行时，要将寄存器中的内容放入当前栈顶单元的上方，成为新的栈顶元素，`pop ax` 等指令执行时，要从栈顶单元中取出数据，送入寄存器中。如何知道哪个单元是栈顶单元呢？

`8086CPU` 中，有两个寄存器，段寄存器 `SS` 和寄存器 `SP`，栈顶的段地址存放在 `SS` 中，偏移地址存放在 `SP` 中。任意时刻，`SS:SP` 指向栈顶元素。

`push` 指令和 `pop` 指令执行时，`CPU` 从 `SS` 和 `SP` 中得到栈顶的地址。

`push ax` 的执行，由以下两步完成:
- `SP=SP-2`，`SS:SP` 指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶
- 将 `ax` 中的内容送入 `SS:SP` 指向的内存单元处，`SS:SP` 此时指向新栈顶。

![056]()

`8086CPU` 中，入栈时，栈顶从高地址向低地址方向增长。

将 10000H~1000FH 这段空间当作栈段，SS=1000H，栈空间大小为 16 字节，栈最底部的字单元地址为 1000:000E。任意时刻，SS:SP 指向栈顶，当栈中只有一个元素的时候，SS=1000H，SP=000EH。栈为空，就相当于栈中唯一的元素出栈，出栈后，SP=SP+2，SP 原来为 000EH，加 2 后 SP-10H，所以，当栈为空的时候，SS=1000H，SP=10H。

换一个角度看，任意时刻，SS:SP 指向栈顶元素，当栈为空的时候，栈中没有元素，也就不存在栈顶元素，所以 SS:SP 只能指向栈的最底部单元下面的单元，该单元的偏移地址为栈最底部的字单元的偏移地址 +2，栈最底部字单元的地址为1000:000E，所以栈空时，SP=0010H。

![057]()

`pop ax` 的执行过程和 `push ax` 刚好相反，由以下两步完成:
- 将 `SS:SP` 指向的内存单元处的数据送入 `ax` 中
- `SP=SP+2`，`SS:SP` 指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。

![058]()

出栈后，`SS:SP` 指向新的栈顶 `1000EH`，`pop` 操作前的栈顶元素 `1000CH` 处的 `2266H` 依然存在，但是，它已不在栈中。当再次执行 `push` 等入栈指令后，`SS:SP` 移至 `1000CH`，并在里面写入新的数据，它将被覆盖。

## 栈顶超界的问题

`SS` 和 `SP` 只是记录了栈顶的地址，依靠 `SS` 和 `SP` 可以保证在入栈和出栈时找到栈顶。可是，如何能够保证在入栈、出栈时，栈顶不会超出栈空间？


![059]()

栈顶超界是危险的，因为既然将一段空间安排为栈，那么在栈空间之外的空间里很可能存放了具有其他用途的数据、代码等，这些数据、代码可能是自己程序中的，也可能是别的程序中的。但是由于在入栈出栈时的不小心，而将这些数据、代码意外地改写，将会引发一连串的错误。

但 `8086CPU` 不保证对栈的操作不会超界。这也就是说，`8086CPU` 只知道栈顶在何处，而不知道安排的栈空间有多大。

在编程的时候要自己操心栈顶超界的问题，要根据可能用到的最大栈空间，来安排栈的大小。

## `push`、`pop` 指令

push 和 pop 指令是可以在寄存器和内存之间传送数据的。

push 和 pop 指令的格式可以是如下形式:
- `push 寄存器` ;将一个寄存器中的数据入栈
- `pop 寄存器`  ;出栈，用一个寄存器接收出栈的数据

也可以是如下形式:
- `push 段寄存器`   ;将一个段寄存器中的数据入栈
- `pop 段寄存器`    ;出栈，用一个段寄存器接收出栈的数据

`push` 和 `pop` 也可以在内存单元和内存单元之间传送数据:
`push` 内存单元;将一个内存字单元处的字入栈(注意：栈操作都是以字为单位)
`pop` 内存单元;出栈，用一个内存字单元接收出栈的数据

比如:

```asm
mov ax,1000H
mov ds,ax   ;内存单元的段地址放在 ds 中
push [0]    ;将 1000:0 处的字压入栈中
pop [2]     ;出栈，出栈的数据送入 1000:2 处
```

指令执行时，`CPU` 要知道内存单元的地址，可以在 `push`、`pop` 指令中只给出内存单元的偏移地址，段地址在指令执行时，`CPU` 从 `ds` 中取得。

`push`、`pop` 实质上就是一种内存传送指令，可以在寄存器和内存之间传送数据，与 `mov` 指令不同的是，`push` 和 `pop` 指令访问的内存单元的地址不是在指令中给出的，而是由 `SS:SP` 指出的。同时，`push` 和 `pop` 指令还要改变 `SP` 中的内容。

`CPU` 执行 `mov` 指令只需一步操作，就是传送，而执行 `push`、`pop` 指令却需要两步操作。执行 `push` 时，`CPU` 的两步操作是：先改变 `SP`，后向 `SS:SP` 处传送。执行 `pop` 时，`CPU` 的两步操作是: 先读取
 `SS:SP` 处的数据，后改变 `SP`。

`push`，`pop` 等栈操作指令，修改的只是 `SP`。也就是说，栈顶的变化范围最大为: `0~FFFFH`。

## 栈段

对于 `8086PC` 机，在编程时，可以根据需要，将一组内存单元定义为一个段。

将长度为 `N` 的一组地址连续起始地址为 `16` 的倍数的内存单元，当作栈空间来用，从而定义了一个栈段。比如，将 `10010H~1001FH` 这段长度为 `16` 字节的内存空间当作栈来用，以栈的方式进行访问这段空间就可以称为一个栈段，段地址为 `1001H`，大小为 `16` 字节。

将一段内存当作栈段，仅仅是在编程时的一种安排，`CPU` 并不会由于这种安排，就在执行 `push`、`pop` 等栈操作指令时自动地将我们定义的栈段当作栈空间来访问。需要将 `SS:SP` 指向我们定义的栈段。

如果将 `10000H~1FFFFH` 这段空间当作栈段，`SS=1000H`，栈空间为 `64KB`，栈最底部的字单元地址为 `1000:FFFE`。任意时刻，`SS:SP` 指向栈顶单元，当栈中只有一个元素的时候，`SS=1000H`，`SP=FFFEH`。栈为空，就相当于栈中唯一的元素出栈，出栈后，`SP=SP+2`。`SP` 原来为 `FFFEH`，加 `2` 后 `SP=0`，所以，当栈为空的时候，`SS=1000H`，`SP=0`。

`push`、`pop` 等指令在执行的时候只修改 `SP`，所以栈顶的变化范围是 `0~FFFFH`，从栈空时候的 `SP=0`，一直压栈，直到栈满时 `SP=0`，如果再次压栈，栈顶将环绕，覆盖了原来栈中的内容。所以一个栈段的容量最大为 `64KB`。

段的综述:


我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元。这完全是我们自己的安排。
- 我们可以用一个段存放数据，将它定义为数据段
- 我们可以用一个段存放代码，将它定义为代码段
- 我们可以用一个段当作栈，将它定义为栈段

我们可以这样安排，但若要让 `CPU` 按照我们的安排来访问这些段，就要:
- 对于数据段，将它的段地址放在 `DS` 中，用 `mov`、`add`、`sub` 等访问内存单元的指令时，`CPU` 就将我们定义的数据段中的内容当作数据来访问
- 对于代码段，将它的段地址放在 `CS` 中，将段中第一条指令的偏移地址放在 IP 中，这样 CPU 就将执行我们定义的代码段中的指令
- 对于栈段，将它的段地址放在 `SS` 中，将栈顶单元的偏移地址放在 `SP` 中，这样 `CPU` 在需要进行栈操作的时候，比如执行 `push`、`pop` 指令等，就将我们定义的栈段当作栈空间来用。

一段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么也不是。关键在于 `CPU` 中寄存器的设置，即 `CS`、`IP`，`SS`、`SP`，`DS` 的指向。